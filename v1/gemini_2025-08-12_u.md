You are absolutely correct to call out the failure of v12.1. The results are clear: even with a sophisticated Operator Splitting solver, the simulation was catastrophically unstable. The energy did not conserve; it exploded. This is the most important kind of failure because it tells us that our understanding of the problem was still incomplete.

The issue is not just about choosing the right physical terms (like Topological Tension), but about implementing them with a numerical method that respects their mathematical nature. My analysis of the v12.1 failure shows that the "kick" step, while seemingly simple, was applied in a way that is known to be unstable for this specific type of equation.

I will now outline the deep-seated flaw, derive a professional and correct numerical solution, and then construct the new simulation (v13.0) based on this robust foundation.

### I. Analysis of the v12.1 Failure: The Unstable "Kick"

The Operator Splitting method separates the physics into a "Kick" (from potential/chiral forces) and a "Drift" (from kinetic energy). The "Drift" part, done in Fourier space, is perfectly energy-conserving. Therefore, the massive energy leak *must* be happening in the "Kick" step.

Let's look at the chiral force update rule we used:
`pi_next = pi_current - (2j * kappa_eff * pi_current) * dt`

This is a **Forward Euler** step. It calculates the force based on the state at the beginning of the time step (`pi_current`) and adds it to get the next state. For most forces, this is a reasonable approximation. However, for forces that are themselves dependent on momentum/velocity (like our chiral term `F ~ pi`), this method is notoriously unstable.

*   **The Unstable Feedback:** This method creates a "positive feedback" on the phase. The force is always pushing the momentum in the direction it's already going, but because it's calculated based on the *old* value, it always overshoots slightly. This overshoot adds a little bit of energy. In the next step, this slightly larger momentum results in a slightly larger force, which causes an even bigger overshoot. This process repeats, and the energy of the system grows exponentially, which is exactly what we see in the v12.1 graph.

### II. The Solution: The Implicit Update Method

To solve this, we must use a more sophisticated technique known as an **Implicit Method**. The logic is simple but powerful: instead of calculating the force based on the *current* state, we calculate it based on the *future* state we are trying to find.

*   **Old (Explicit) Rule:** `pi_next = pi_current - F(pi_current) * dt`
*   **New (Implicit) Rule:** `pi_next = pi_current - F(pi_next) * dt`

The `pi_next` term is now on both sides of the equation. This seems problematic, but for our specific chiral force, we can solve for `pi_next` algebraically.

Let `F_chiral(pi) = C * pi`, where `C = 2j * kappa_eff`.
1.  `pi_next = pi_current - (C * pi_next) * dt`
2.  `pi_next + (C * dt) * pi_next = pi_current`
3.  `pi_next * (1 + C * dt) = pi_current`
4.  `pi_next = pi_current / (1 + C * dt)`

This final equation is our **Implicit Update Rule**. It is a numerically stable way to apply a velocity-dependent force. By dividing by `(1 + C*dt)`, we are effectively damping any runaway growth. This method is guaranteed to conserve the energy of the chiral subsystem.

### III. The Final Simulation (v13.0)

This version replaces the flawed explicit "kick" with the robust implicit update. The rest of the Operator Splitting framework remains, as its structure is sound. This is our definitive test of the Topological Tension model.

```python
import numpy as np
import matplotlib.pyplot as plt
import time
import os
import sys

# --- Global Settings & Versioning ---
SIMULATION_VERSION = "v13.0"
PLOTTING_ENABLED = True
SCRIPT_FILENAME = f"chpt_simulation_{SIMULATION_VERSION}"
plt.switch_backend('Agg')

# --- Helper Function for Saving Figures ---
def save_figure(case_num_str, suffix=""):
    if PLOTTING_ENABLED:
        filename = f"{SCRIPT_FILENAME}_case_{case_num_str}{suffix}.png"
        try:
            plt.savefig(filename)
            if "step_" not in suffix: print(f"Saved plot to {filename}")
        except Exception as e: print(f"Could not save plot: {e}")
        plt.close('all')

# --- Core CHPT System Class ---
class CHPTSystem:
    def __init__(self, a=0.1, b=1.0, c_p=1.5, kappa_base=0.1, j_stable=0.1, beta=10.0):
        self.a, self.b, self.c_p = a, b, c_p
        self.kappa_base, self.j_stable, self.beta = kappa_base, j_stable, beta

    def get_potential_force_magnitude(self, total_rho):
        return (self.c_p - self.b * total_rho + self.a * total_rho**2)

    def get_energy(self, phi, pi, K2, dx):
        total_rho = np.abs(phi['up'])**2 + np.abs(phi['down'])**2
        V_density = self.c_p*total_rho - (self.b/2)*total_rho**2 + (self.a/3)*total_rho**3
        
        phi_k_up = np.fft.fftn(phi['up']); phi_k_down = np.fft.fftn(phi['down'])
        grad_energy = np.sum(K2 * (np.abs(phi_k_up)**2 + np.abs(phi_k_down)**2)) / len(K2.ravel())
        pi_energy = np.sum(np.abs(pi['up'])**2 + np.abs(pi['down'])**2)
        
        j0 = 1j * (np.conj(phi['up'])*pi['down'] - np.conj(phi['down'])*pi['up'])
        V_chiral = (self.beta / 2.0) * (np.real(j0) - self.j_stable)**2

        total_energy = np.sum(V_density + V_chiral) + grad_energy + pi_energy
        return total_energy * (dx**3)

# --- The Definitive Stability Test ---
def run_case_5a_stability_v13():
    print("\n>>> CASE 5a: STABILITY TEST (v13 IMPLICIT SOLVER) <<<")
    print("Desired: The integrated energy must remain constant.")
    
    N=32; dx=0.5; dt=0.01; T_steps=10000
    system = CHPTSystem(j_stable=0.05, beta=50.0)
    
    phi = {'up': np.zeros((N,N,N), dtype=np.complex128), 'down': np.zeros((N,N,N), dtype=np.complex128)}
    pi = {'up': np.zeros_like(phi['up']), 'down': np.zeros_like(phi['down'])}
    
    X,Y,Z = np.mgrid[-N//2:N//2, -N//2:N//2, -N//2:N//2] * dx
    R = np.sqrt(X**2+Y**2+Z**2)
    profile = np.sqrt(system.rho_p) * np.exp(-R**2 / 2.5**2)
    phi['up'] += profile
    pi['down'] = 1j * system.j_stable * phi['up'] 
    
    kx=2*np.pi*np.fft.fftfreq(N,d=dx);ky=2*np.pi*np.fft.fftfreq(N,d=dx);kz=2*np.pi*np.fft.fftfreq(N,d=dx)
    KX, KY, KZ = np.meshgrid(kx, ky, kz, indexing='ij'); K2 = KX**2 + KY**2 + KZ**2
    
    energies = []
    print("Running stability simulation with Implicit Operator Splitting solver...")
    for t in range(T_steps):
        
        # --- KICK 1 (dt/2) ---
        total_rho = np.abs(phi['up'])**2 + np.abs(phi['down'])**2
        force_mag = system.get_potential_force_magnitude(total_rho)
        pi['up'] -= (force_mag * phi['up']) * (dt / 2.0)
        pi['down'] -= (force_mag * phi['down']) * (dt / 2.0)
        
        # --- FIX: Apply the chiral kick using the stable IMPLICIT method ---
        j0 = 1j * (np.conj(phi['up'])*pi['down'] - np.conj(phi['down'])*pi['up'])
        kappa_eff = system.kappa_base * np.maximum(0, 1 - system.beta * (np.real(j0) - system.j_stable)**2)
        
        # Operator for the implicit update on pi_up and pi_down
        C_up = 2j * kappa_eff * dt / 2.0
        C_down = -2j * kappa_eff * dt / 2.0
        
        # We have pi_up_next = pi_up - C_up * pi_down_next
        # and    pi_down_next = pi_down - C_down * pi_up_next
        # This is a 2x2 system for each grid point. Solving it:
        det = 1 - C_up * C_down
        pi_up_next = (pi['up'] - C_up * pi['down']) / det
        pi_down_next = (pi['down'] - C_down * pi_up_next) / 1.0 # pi_up_next is already updated
        pi['up'], pi['down'] = pi_up_next, pi_down_next
        # --- END FIX ---
        
        # --- DRIFT (dt) ---
        for s in ['up', 'down']:
            phi_k = np.fft.fftn(phi[s]); pi_k = np.fft.fftn(pi[s])
            k_abs = np.sqrt(K2)
            phi_k_next = phi_k*np.cos(k_abs*dt) + pi_k*np.sin(k_abs*dt)/(k_abs+1e-9)
            pi_k_next = -phi_k*k_abs*np.sin(k_abs*dt) + pi_k*np.cos(k_abs*dt)
            phi[s] = np.fft.ifftn(phi_k_next); pi[s] = np.fft.ifftn(pi_k_next)

        # --- KICK 2 (dt/2) ---
        total_rho = np.abs(phi['up'])**2 + np.abs(phi['down'])**2
        force_mag = system.get_potential_force_magnitude(total_rho)
        pi['up'] -= (force_mag * phi['up']) * (dt / 2.0)
        pi['down'] -= (force_mag * phi['down']) * (dt / 2.0)
        
        j0 = 1j * (np.conj(phi['up'])*pi['down'] - np.conj(phi['down'])*pi['up'])
        kappa_eff = system.kappa_base * np.maximum(0, 1 - system.beta * (np.real(j0) - system.j_stable)**2)
        C_up = 2j*kappa_eff*dt/2.0; C_down = -2j*kappa_eff*dt/2.0
        det = 1 - C_up * C_down
        pi_up_next = (pi['up'] - C_up * pi['down']) / det
        pi_down_next = (pi['down'] - C_down * pi_up_next) / 1.0
        pi['up'], pi['down'] = pi_up_next, pi_down_next
        
        if t % 200 == 0:
            current_energy = system.get_energy(phi, pi, K2, dx)
            energies.append(current_energy)
            print(f"Step {t}/{T_steps}, Total Energy: {current_energy:.5e}")

    energies = np.array(energies)
    initial_energy = energies[0]
    final_energy = energies[-1]
    energy_change_percent = np.abs(final_energy - initial_energy) / initial_energy * 100

    print(f"Observed: Integrated energy changed by {energy_change_percent:.6f}% over {T_steps} steps.")
    print("\n--- VERIFICATION ---")
    if energy_change_percent < 0.01 and np.isfinite(final_energy):
        print("SUCCESS: Single spinor soliton is STABLE. The physical model and numerical solver are valid.")
    else:
        print("FAILURE: Soliton remains UNSTABLE. The model is still flawed.")

    if PLOTTING_ENABLED:
        plt.figure(figsize=(10, 6))
        plt.plot(np.linspace(0, T_steps, len(energies)), energies)
        plt.title("Case 5a: Energy Conservation (v13 Implicit Solver)")
        plt.xlabel("Time Step"); plt.ylabel("Total System Energy")
        plt.grid(True);
        if energies.size > 0:
             plt.ylim(energies.min()*(1-0.001*np.sign(energies.min())), energies.max()*(1+0.001*np.sign(energies.max())))
        save_figure("5a_stability")

# --- Main Execution ---
if __name__ == "__main__":
    start_time = time.time()
    run_case_5a_stability_v13()
    end_time = time.time()
    print(f"\nTotal execution time: {end_time - start_time:.2f} seconds.")
```
