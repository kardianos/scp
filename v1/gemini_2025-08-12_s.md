Of course. The results from v10.0 are definitive: the simulation is numerically unstable, and therefore, physically meaningless. The `overflow` and `nan` values are the simulation screaming that the mathematical method used to solve the equations is flawed.

Your directive to stop and think is precisely the correct one. The problem is not with the physical concepts (the terms in the Lagrangian), but with the naive numerical method (the explicit FDTD scheme) used to simulate them. The feedback loop between the various force terms is too strong and is causing the energy of the system to explode.

I will now outline the failure, propose a professional and robust solution, and then provide a complete, new simulation built on this superior method.

### Part 1: Analysis of the Numerical Instability

The failure in v10.0 is a classic example of what happens when a simple, explicit time-stepping scheme is applied to a "stiff" system of partial differential equations.

1.  **The Core Problem:** The equation of motion `∂²Φ/∂t² = F_kinetic + F_potential + F_chiral + F_bias` contains multiple terms with vastly different characteristics.
    *   `F_kinetic` (`∇²Φ`) is a standard wave operator.
    *   `F_potential` (`-V' * Φ`) is a non-linear "restoring" force.
    *   `F_chiral` and `F_bias` are "velocity-dependent" forces (`~dΦ/dt`).

2.  **The Unstable Feedback Loop:** Our previous FDTD method, `Φ_next = 2Φ - Φ_prev + dt² * F_total`, calculates all forces based on the state at time `t`. When the `dΦ/dt` term is approximated as `(Φ - Φ_prev)/dt`, it creates a direct, high-gain feedback loop. Any tiny numerical error at one time step is amplified by the chiral/bias terms, which then creates a larger error in the next potential force calculation, which creates an even larger error in the next chiral calculation. This non-physical, exponential growth of energy is what causes the `overflow`.

3.  **The Professional Solution: Operator Splitting**
    Instead of trying to solve the full, complex equation in one step, we "split" the physics into a sequence of simpler updates, each of which can be solved with a numerically stable method. We will use a common and robust technique called **Strang Splitting**.

    The evolution from time `t` to `t+dt` will be approximated as three steps:
    *   **Step A: A "Kick" from all Potential-like Forces.** We apply the forces from the self-interaction potential and the chiral/bias terms for half a time step (`dt/2`). These terms are local in space.
    *   **Step B: A "Drift" from the Kinetic Term.** We evolve the system under only the kinetic (`∇²`) term for a full time step (`dt`). This is most accurately and stably done in Fourier space.
    *   **Step C: Another "Kick".** We apply the potential-like forces again for the second half of the time step (`dt/2`).

    This "Kick-Drift-Kick" leapfrog method is vastly more stable because it decouples the stiff, non-linear terms from the wave propagation, preventing the unstable feedback loop.

### Part 2: Revised Conceptual and Mathematical Model

The conceptual model remains the same as outlined previously. The key change is in the mathematical method of the numerical solver, which will now accurately reflect the physics without introducing artificial instabilities.

### Part 3: The Numerical Model (v11.0)

This version is a complete rewrite of the simulation core, implementing the Operator Splitting method. It is designed for stability and physical accuracy.

```python
import numpy as np
import matplotlib.pyplot as plt
import time
import os
import sys

# --- Global Settings & Versioning ---
SIMULATION_VERSION = "v11.0"
PLOTTING_ENABLED = True
SCRIPT_FILENAME = f"chpt_simulation_{SIMULATION_VERSION}"
plt.switch_backend('Agg')

# --- Helper Function for Saving Figures ---
def save_figure(case_num_str, suffix=""):
    if PLOTTING_ENABLED:
        filename = f"{SCRIPT_FILENAME}_case_{case_num_str}{suffix}.png"
        try: plt.savefig(filename)
        except Exception as e: print(f"Could not save plot: {e}")
        plt.close('all')

# --- Core CHPT System Class ---
class CHPTSystem:
    def __init__(self, a=0.1, b=1.0, c_p=1.5, kappa=0.05, eta=0.01):
        self.a, self.b, self.c_p, self.kappa, self.eta = a, b, c_p, kappa, eta
        self.c = 299792458.0; self.G = 6.67430e-11
        self.rho_0, self.rho_p = self._calculate_potential_minima()
        if self.rho_0 is None: raise ValueError("Invalid potential parameters.")

    def _calculate_potential_minima(self):
        d = self.b**2 - 4*self.a*self.c_p
        return (None, None) if d < 0 else ((self.b - np.sqrt(d))/(2*self.a), (self.b + np.sqrt(d))/(2*self.a))
    
    def get_potential_force(self, total_rho):
        # This is V'(rho)
        return (self.c_p - self.b * total_rho + self.a * total_rho**2)

# --- The New, Stable Operator Splitting Solver ---
def run_case_5a_spinor_stability():
    """Prerequisite test: Is a single soliton stable with the new solver?"""
    print("\n>>> CASE 5a: SINGLE SPINOR SOLITON STABILITY TEST (v11 Solver) <<<")
    print("Desired: The integrated density of a single particle should remain constant.")
    
    # High-fidelity parameters for a serious test
    N=64; dx=0.4; dt=0.02; T_steps=5000
    system = CHPTSystem()
    
    # --- Field Initialization ---
    phi = {'up': np.zeros((N,N,N), dtype=np.complex128), 'down': np.zeros((N,N,N), dtype=np.complex128)}
    # The momentum field (phi_dot)
    pi = {'up': np.zeros_like(phi['up']), 'down': np.zeros_like(phi['down'])}
    
    X,Y,Z = np.mgrid[-N//2:N//2, -N//2:N//2, -N//2:N//2] * dx
    R = np.sqrt(X**2+Y**2+Z**2)
    phi['up'] += (np.sqrt(system.rho_p)) * np.exp(-R**2 / 2.5**2)
    
    # --- Setup for Fourier Space (Kinetic Drift) ---
    kx = 2 * np.pi * np.fft.fftfreq(N, d=dx)
    ky = 2 * np.pi * np.fft.fftfreq(N, d=dx)
    kz = 2 * np.pi * np.fft.fftfreq(N, d=dx)
    KX, KY, KZ = np.meshgrid(kx, ky, kz, indexing='ij')
    K2 = KX**2 + KY**2 + KZ**2
    
    # Define external bias field
    C_bias_T = 0.05
    
    initial_density = np.sum(np.abs(phi['up'])**2 + np.abs(phi['down'])**2)
    
    print("Running stable Operator Splitting simulation...")
    for t in range(T_steps):
        # --- STEP A: Potential and Chiral Kick (dt/2) ---
        total_rho = np.abs(phi['up'])**2 + np.abs(phi['down'])**2
        force_mag = system.get_potential_force(total_rho)
        
        pi['up'] -= (force_mag * phi['up']) * (dt / 2.0)
        pi['down'] -= (force_mag * phi['down']) * (dt / 2.0)
        
        # Chiral/Bias terms affect momentum (pi is phi_dot)
        pi['up'] -= (2j * system.kappa * pi['down'] + 2j * system.eta * C_bias_T * pi['up']) * (dt / 2.0)
        pi['down'] -= (-2j * system.kappa * pi['up'] + 2j * system.eta * C_bias_T * pi['down']) * (dt / 2.0)
        
        # --- STEP B: Kinetic Drift (dt) ---
        for s in ['up', 'down']:
            phi_k = np.fft.fftn(phi[s])
            pi_k = np.fft.fftn(pi[s])
            
            # Evolve in Fourier space
            phi_k_next = phi_k * np.cos(np.sqrt(K2) * dt) + pi_k * np.sin(np.sqrt(K2) * dt) / (np.sqrt(K2) + 1e-9)
            pi_k_next = -phi_k * np.sqrt(K2) * np.sin(np.sqrt(K2) * dt) + pi_k * np.cos(np.sqrt(K2) * dt)
            
            phi[s] = np.fft.ifftn(phi_k_next)
            pi[s] = np.fft.ifftn(pi_k_next)

        # --- STEP C: Second Potential and Chiral Kick (dt/2) ---
        total_rho = np.abs(phi['up'])**2 + np.abs(phi['down'])**2
        force_mag = system.get_potential_force(total_rho)
        
        pi['up'] -= (force_mag * phi['up']) * (dt / 2.0)
        pi['down'] -= (force_mag * phi['down']) * (dt / 2.0)
        
        pi['up'] -= (2j * system.kappa * pi['down'] + 2j * system.eta * C_bias_T * pi['up']) * (dt / 2.0)
        pi['down'] -= (-2j * system.kappa * pi['up'] + 2j * system.eta * C_bias_T * pi['down']) * (dt / 2.0)

    final_density = np.sum(np.abs(phi['up'])**2 + np.abs(phi['down'])**2)
    density_change = np.abs(final_density - initial_density) / initial_density

    print(f"Observed: Integrated density changed by {density_change*100:.6f}% over {T_steps} steps.")
    print("\n--- VERIFICATION ---")
    if density_change < 0.001:
        print("SUCCESS: Single spinor soliton is stable. This model is valid.")
        return True
    else:
        print("FAILURE: Soliton is unstable even with the advanced solver. The physics model needs revision.")
        return False

# --- Full Regression Test Suite (Unchanged) ---
def run_case_1_gravity():
    print("\n>>> CASE 1: VERIFICATION OF LONG-RANGE GRAVITY FIELD <<<")
    # ... code is identical to v9.0 ...
    system = CHPTSystem(); m_source = 5.972e24; r = np.linspace(6.371e6, 5e7, 4000)
    k = 2 * system.G * m_source / system.c**2; rho_gravity = system.rho_0 * np.exp(-k / r)
    a_chpt = -0.5 * system.c**2 * np.gradient(np.log(rho_gravity), r[1]-r[0])
    a_newton = -system.G * m_source / r**2; error = np.mean(np.abs((a_chpt - a_newton) / a_newton))
    print(f"Desired: Deviation < 1%. Observed: {error*100:.4f}%")
    if error < 0.01: print("--- VERIFICATION --- \nSUCCESS."); save_figure("1_gravity")
    else: print("--- VERIFICATION --- \nFAILURE.")

def run_case_2_rest_mass():
    print("\n>>> CASE 2: RELATIVISTIC MECHANICS (REST MASS) <<<")
    # ... code is identical to v9.0 ...
    system = CHPTSystem()
    N,dx=2000,0.01;x=(np.arange(N)-N//2)*dx;phi=np.sqrt(system.rho_0)+(np.sqrt(system.rho_p)-np.sqrt(system.rho_0))*np.exp(-x**2)
    grads=np.gradient(phi,dx);grad_sq=np.abs(grads)**2;pot_V=system.c_p*phi**2-(system.b/2)*phi**4+(system.a/3)*phi**6
    energy=np.sum(grad_sq+pot_V)*dx; print(f"Desired: Positive energy. Observed: {energy:.4e}")
    if energy>0: print("--- VERIFICATION ---\nSUCCESS.")
    else: print("--- VERIFICATION ---\nFAILURE.")

def run_case_4_interference():
    print("\n>>> CASE 4: EMF PROPAGATION (DOUBLE-SLIT INTERFERENCE) <<<")
    # ... code is identical to v9.0 ...
    print("Desired: Clear interference pattern.")
    wl=500e-9;k=2*np.pi/wl;sw=2*wl;ss=10*sw;sd=0.01;scw=0.001;ns=50
    s1y=np.linspace(-ss/2-sw/2,-ss/2+sw/2,ns);s2y=np.linspace(ss/2-sw/2,ss/2+sw/2,ns)
    slits=np.concatenate([s1y,s2y]);scr_y=np.linspace(-scw/2,scw/2,2000);field=np.zeros_like(scr_y,dtype=np.complex128)
    for y in slits:field+=np.exp(1j*k*np.sqrt(sd**2+(scr_y-y)**2))
    intensity=np.abs(field)**2;intensity/=intensity.max();print(f"Observed: {len(np.where(intensity>0.8)[0])} peaks.")
    if len(np.where(intensity>0.8)[0])>10:print("--- VERIFICATION ---\nSUCCESS."); save_figure("4_interference")
    else:print("--- VERIFICATION ---\nFAILURE.")

def run_case_6_tunneling():
    print("\n>>> CASE 6: 'QUANTUM' TUNNELING VIA FDTD <<<")
    # ... code is identical to v9.0 ...
    print("Desired: Non-zero transmitted intensity.")
    N=5000;T=12000;dx=1.0;dt=0.2;phi=np.zeros(N,dtype=np.complex128);phi_p=np.zeros(N,dtype=np.complex128)
    k0=np.pi/30;E0=np.sqrt(1+k0**2);x0=N//5;sig=40.0;x=np.arange(N)*dx
    phi=np.exp(-(x-x0)**2/(2*sig**2))*np.exp(1j*k0*(x-x0));phi_p=np.exp(-(x-x0-k0*dt/E0)**2/(2*sig**2))*np.exp(1j*k0*(x-x0-k0*dt/E0))
    V=np.zeros(N);bs,be=N//2,N//2+50;bh=0.015;V[bs:be]=bh
    init_I=np.sum(np.abs(phi)**2);print(f"KE:{E0-1:.4f}. Barrier:{bh:.4f}")
    for t in range(T):lap=np.roll(phi,1)+np.roll(phi,-1)-2*phi;phi_n=2*phi-phi_p+(dt/dx)**2*lap-dt**2*V*phi;phi_p,phi=phi,phi_n
    ref_I=np.sum(np.abs(phi[:bs])**2);tun_I=np.sum(np.abs(phi[be:])**2)
    print(f"Observed: Reflected={ref_I/init_I*100:.2f}%, Tunneled={tun_I/init_I*100:.2f}%")
    if 0.01<tun_I/init_I<0.99:print("--- VERIFICATION ---\nSUCCESS."); save_figure("6_tunneling")
    else:print("--- VERIFICATION ---\nFAILURE.")

# --- Main Execution ---
if __name__ == "__main__":
    start_time = time.time()
    
    # The entire workflow now hinges on this one, critical test.
    is_particle_stable = run_case_5a_spinor_stability()
    
    if is_particle_stable:
        print("\n--- STABILITY ACHIEVED: RUNNING FULL REGRESSION SUITE ---")
        # If stable, we can now trust the framework enough to run the other cases.
        # The next step would be to build Case 5b (interaction) using this stable solver.
        run_case_1_gravity()
        run_case_2_rest_mass()
        run_case_4_interference()
        run_case_6_tunneling()
    else:
        print("\n--- FRAMEWORK UNSTABLE: Further simulations are invalid. ---")
    
    end_time = time.time()
    print(f"\nTotal execution time: {end_time - start_time:.2f} seconds.")
```
