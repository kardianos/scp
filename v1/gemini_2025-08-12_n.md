Of course. This is the necessary and definitive test. We will simulate all three proposed models for the atomic force with high fidelity and compare their results.

The previous simulations failed because they did not correctly model the core physical principle: **a chiral-dependent interaction**. A simple scalar "stiffness" is insufficient. The force between two solitons must emerge from the dynamics of their internal chiral states.

Below is a comprehensive framework that implements and tests all three proposed models.

*   **Model 1: The Effective Chiral Potential.** An analytical model that is computationally fast but less fundamental. It defines the interaction as a pre-canned potential function dependent on spin alignment.
*   **Model 2: The Modulated Chiral Force.** A 4D FDTD simulation where the strength of the chiral interaction (`Îº`) is no longer a constant but becomes a dynamic field that increases dramatically when two solitons overlap, creating a powerful, localized force.
*   **Model 3: The Multi-Component Field (Spinor).** The most physically rigorous approach. It treats a particle as a two-component field (`up` and `down`). The force emerges naturally from the coupled non-linear equations governing these two components, without any ad-hoc interaction terms.

Each model will be subjected to tests for both short-range repulsion and mid-range attraction to see which, if any, can reproduce the full nuclear force profile.

### CHPT Simulation Framework, Version v7.0

```python
import numpy as np
import matplotlib.pyplot as plt
import time
import os
import sys

# --- Global Settings & Versioning ---
SIMULATION_VERSION = "v7.0"
PLOTTING_ENABLED = True
SCRIPT_FILENAME = f"chpt_simulation_{SIMULATION_VERSION}"
plt.switch_backend('Agg')

# --- Helper Function for Saving Figures ---
def save_figure(case_num_str, suffix=""):
    if PLOTTING_ENABLED:
        filename = f"{SCRIPT_FILENAME}_case_{case_num_str}{suffix}.png"
        try:
            plt.savefig(filename)
            if "step_" not in suffix:
                print(f"Saved plot to {filename}")
        except Exception as e:
            print(f"Could not save plot: {e}")
        plt.close('all')

# --- Core CHPT System Class ---
class CHPTSystem:
    def __init__(self, a=0.1, b=1.0, c_p=1.5, kappa=0.05):
        self.a, self.b, self.c_p, self.kappa = a, b, c_p, kappa
        self.rho_0, self.rho_p = self._calculate_potential_minima()
        if self.rho_0 is None: raise ValueError("Invalid potential parameters.")

    def _calculate_potential_minima(self):
        d = self.b**2 - 4*self.a*self.c_p
        return (None, None) if d < 0 else ((self.b - np.sqrt(d))/(2*self.a), (self.b + np.sqrt(d))/(2*self.a))

    def get_force_term(self, phi):
        rho = np.abs(phi)**2
        return (self.c_p - self.b * rho + self.a * rho**2) * phi

# --- Model 1: Effective Chiral Potential ---
def run_case_5_model_1_potential():
    print("\n>>> MODEL 1: EFFECTIVE CHIRAL POTENTIAL <<<")
    print("Desired: Potential well for anti-aligned spins; repulsion for aligned spins.")
    
    # Model Parameters
    A = 10.0  # Repulsive strength
    B = 25.0  # Attractive strength
    r0 = 0.5  # Repulsive range
    r1 = 0.8  # Attractive range
    
    d = np.linspace(0.2, 5.0, 500)
    
    # Case A: Anti-aligned spins (S1 . S2 = -1) -> binding
    U_attractive = A * np.exp(-d / r0) - B * np.exp(-d / r1) * (-1)
    
    # Case B: Aligned spins (S1 . S2 = 1) -> repulsive
    U_repulsive = A * np.exp(-d / r0) - B * np.exp(-d / r1) * (1)
    
    min_energy_idx = np.argmin(U_attractive)
    binding_energy = U_attractive[min_energy_idx]
    binding_distance = d[min_energy_idx]

    print(f"Observed (Anti-aligned): Found potential well with binding energy {binding_energy:.2f} at d={binding_distance:.2f}")
    print(f"Observed (Aligned): Minimum energy is {np.min(U_repulsive):.2f}, indicating no binding.")

    print("\n--- VERIFICATION ---")
    if binding_energy < 0 and np.min(U_repulsive) > 0:
        print("SUCCESS: The effective potential model correctly reproduces the desired force profile.")
    else:
        print("FAILURE: The model does not produce the correct profile.")
        
    plt.figure(figsize=(10, 6))
    plt.plot(d, U_attractive, 'b-', label='Attractive Channel (Spins Anti-Aligned)')
    plt.plot(d, U_repulsive, 'r--', label='Repulsive Channel (Spins Aligned)')
    plt.axhline(0, color='k', linestyle=':', linewidth=0.5)
    plt.axvline(binding_distance, color='g', linestyle='--', label=f'Binding Distance = {binding_distance:.2f}')
    plt.title("Model 1: Effective Chiral Potential")
    plt.xlabel("Separation (d)"); plt.ylabel("Interaction Energy (E)")
    plt.legend(); plt.grid(True); plt.ylim(min(U_attractive)*1.2, max(U_repulsive)*0.5)
    save_figure("5_model_1_potential")

# --- Model 2: Modulated Chiral Force in FDTD ---
def run_case_5_model_2_modulated_kappa():
    print("\n>>> MODEL 2: MODULATED CHIRAL FORCE (4D FDTD) <<<")
    print("Desired: Repulsion at short range due to intense chiral force in overlap region.")

    N=32; dx=0.5; dt=0.05; T_steps=1000; d_initial=4.0
    system = CHPTSystem(kappa=0.01) # Base kappa
    kappa_1 = 2.5 # Overlap-dependent kappa strength

    phi=np.full((N,N,N), np.sqrt(system.rho_0), dtype=np.complex128)
    X,Y,Z = np.mgrid[-N//2:N//2, -N//2:N//2, -N//2:N//2] * dx
    sigma=2.0
    
    R1=np.sqrt(X**2+Y**2+(Z+d_initial/2)**2); p1=(np.sqrt(system.rho_p)-np.sqrt(system.rho_0))*np.exp(-R1**2/sigma**2)
    R2=np.sqrt(X**2+Y**2+(Z-d_initial/2)**2); p2=(np.sqrt(system.rho_p)-np.sqrt(system.rho_0))*np.exp(-R2**2/sigma**2)
    phi += p1 * np.exp(1j*1.0) + p2 * np.exp(-1j*1.0)
    phi_prev = phi.copy()

    initial_separation = 0
    for t in range(T_steps):
        d_phi_dt = (phi - phi_prev) / dt
        lap_phi = (np.roll(phi,1,0)+np.roll(phi,-1,0)+np.roll(phi,1,1)+np.roll(phi,-1,1)+
                   np.roll(phi,1,2)+np.roll(phi,-1,2)-6*phi)/dx**2
        force_term = system.get_force_term(phi)
        
        # Modulated kappa depends on local density
        rho = np.abs(phi)**2
        kappa_eff = system.kappa + kappa_1 * (rho - system.rho_0)**2
        chiral_force = 2j * kappa_eff * d_phi_dt
        
        phi_next = 2*phi - phi_prev + dt**2 * (lap_phi - force_term - chiral_force)
        phi_prev, phi = phi, phi_next

        if t == 0 or t == T_steps - 1:
            density=np.abs(phi)**2; zc=Z[0,0,:]; d_z1=np.sum(density[:,:,:N//2],(0,1)); d_z2=np.sum(density[:,:,N//2:],(0,1))
            pos1=np.sum(zc[:N//2]*d_z1)/(np.sum(d_z1)+1e-9); pos2=np.sum(zc[N//2:]*d_z2)/(np.sum(d_z2)+1e-9)
            separation = pos2 - pos1
            if t == 0: initial_separation = separation
    
    final_separation = separation
    print(f"Observed: Initial separation = {initial_separation:.3f}, Final separation = {final_separation:.3f}")
    
    print("\n--- VERIFICATION ---")
    if final_separation > d_initial + 0.2: print("SUCCESS: Model produced strong short-range repulsion.")
    else: print("FAILURE: Model did not produce significant repulsion.")

# --- Model 3: Multi-Component Field (Spinor) ---
def run_case_5_model_3_spinor_field():
    print("\n>>> MODEL 3: MULTI-COMPONENT (SPINOR) FIELD (4D FDTD) <<<")
    print("Desired: Force profile emerges naturally from coupled equations.")

    N=32; dx=0.5; dt=0.05; T_steps=2000; d_initial=7.0
    system = CHPTSystem(kappa=0.2)
    
    # Two component fields for spin-up and spin-down
    phi_up = np.zeros((N,N,N), dtype=np.complex128)
    phi_down = np.zeros((N,N,N), dtype=np.complex128)
    
    X,Y,Z = np.mgrid[-N//2:N//2,-N//2:N//2,-N//2:N//2]*dx
    sigma=2.0
    
    # Particle 1: Mostly Up
    R1 = np.sqrt(X**2+Y**2+(Z+d_initial/2)**2)
    phi_up += (np.sqrt(system.rho_p)) * np.exp(-R1**2 / sigma**2)

    # Particle 2: Mostly Down
    R2 = np.sqrt(X**2+Y**2+(Z-d_initial/2)**2)
    phi_down += (np.sqrt(system.rho_p)) * np.exp(-R2**2 / sigma**2)
    
    phi_up_prev, phi_down_prev = phi_up.copy(), phi_down.copy()
    
    positions = []
    for t in range(T_steps):
        # --- Update for phi_up ---
        total_phi = np.sqrt(np.abs(phi_up)**2 + np.abs(phi_down)**2 + system.rho_0)
        lap_up = (np.roll(phi_up,1,0)+np.roll(phi_up,-1,0)+np.roll(phi_up,1,1)+np.roll(phi_up,-1,1)+
                  np.roll(phi_up,1,2)+np.roll(phi_up,-1,2)-6*phi_up)/dx**2
        force_up = system.get_force_term(total_phi) * (phi_up / (total_phi + 1e-9))
        chiral_up = 2j * system.kappa * (phi_down - phi_down_prev) / dt # Couples to other field
        phi_up_next = 2*phi_up - phi_up_prev + dt**2 * (lap_up - force_up - chiral_up)
        
        # --- Update for phi_down ---
        lap_down = (np.roll(phi_down,1,0)+np.roll(phi_down,-1,0)+np.roll(phi_down,1,1)+np.roll(phi_down,-1,1)+
                    np.roll(phi_down,1,2)+np.roll(phi_down,-1,2)-6*phi_down)/dx**2
        force_down = system.get_force_term(total_phi) * (phi_down / (total_phi + 1e-9))
        chiral_down = 2j * system.kappa * (phi_up - phi_up_prev) / dt # Couples to other field
        phi_down_next = 2*phi_down - phi_down_prev + dt**2 * (lap_down - force_down - chiral_down)

        phi_up_prev, phi_up = phi_up, phi_up_next
        phi_down_prev, phi_down = phi_down, phi_down_next

        if t % 200 == 0:
            zc = Z[0,0,:]; d_up=np.sum(np.abs(phi_up)**2,(0,1)); d_down=np.sum(np.abs(phi_down)**2,(0,1))
            pos_up=np.sum(zc*d_up)/(np.sum(d_up)+1e-9); pos_down=np.sum(zc*d_down)/(np.sum(d_down)+1e-9)
            positions.append(pos_down - pos_up)
            print(f"Step {t}, Separation: {positions[-1]:.3f}")

    final_separation = positions[-1]
    initial_separation = positions[0]
    print(f"Observed: Initial separation = {initial_separation:.3f}, Final separation = {final_separation:.3f}")

    print("\n--- VERIFICATION ---")
    if final_separation < initial_separation - 0.2:
        print("SUCCESS: Spinor model produced a net attractive force.")
    else:
        print("FAILURE: Spinor model did not produce significant attraction.")

# --- Main Execution ---
if __name__ == "__main__":
    start_time = time.time()
    
    # Run the three atomic force models for comparison
    run_case_5_model_1_potential()
    run_case_5_model_2_modulated_kappa()
    run_case_5_model_3_spinor_field()
    
    # Also run a quick regression test on a previously successful case
    print("\n\n--- REGRESSION TESTS ---")
    run_case_1_gravity()
    
    end_time = time.time()
    print(f"\nTotal execution time: {end_time - start_time:.2f} seconds.")
```
